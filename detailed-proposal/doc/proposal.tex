\documentclass[a4paper, 11pt]{article}

\input{packages.tex}
\input{header.tex}

\title{Detailed Master Thesis Proposal:\\\vspace{0.5cm}{\Huge Functional Property Discovery and Corresponding Test Generation in Haskell}}
\author{Tom Sydney Kerckhove}
\begin{document}
\maketitle

\section{Introduction and Motivation}

\newpage

\section{Type-guided property discovery}

\begin{de}
  A \emph{property} is any Haskell function with a type of the form \h{a -> Bool}.
\end{de}

\begin{ex}
  Examples of properties include \h{sorted :: forall a. Ord a => [a] -> Bool}, \h{increasing :: forall a. Ord a => (a, a) -> Bool} and even the degenerate \h{id :: Bool -> Bool}.

  Note that every boolean function with multiple arguments can be rewritten as a property by uncurrying the arguments.
\end{ex}

\begin{de}
  A \emph{scope} is a set of functions.
  We say that a function is \emph{in scope} if it is an element of the scope.
\end{de}

\begin{de}
  Given a scope, a property is a property \emph{of that scope} if it is made up of functions in scope.
  \footnote{How functions are `made-up' is not strictly defined here. We could restrict this to function application, but choosing to allow more syntax may allow for more building blocks.}
\end{de}

\section{Type-guided property discovery}

The following algorithm will allow for the discovery of properties given a scope of functions.
It can be generalised to discover functions given their type, but the example that follows is restricted to properties.

\subsection{Context}

Input: A scope of functions.\\
Output: All possible properties that can be built in this scope.
\footnote{
  Note that this section does not discuss how to choose a scope.
  That problem has no 'correct' solution and will have to be solved later.
}

The following running example will be used, but the algorithm is explained sufficiently generally as well.

Consider the following scope as input.

\begin{itemize}
  \item \h{sorted :: Ord a => [a] -> Bool}
  \item \h{sort :: Ord a => [a] -> [a]}
  \item \h{isPermutationOf :: Eq a => [a] -> [a] -> Bool}
\end{itemize}

Only these three functions are in scope, we limit the scope to these explicitly mentioned functions.
This means that even commonly used functions like\\ \h{(==) :: Eq a => a -> a -> Bool} or \h{(.) :: (b -> c) -> (a -> b) -> a -> c} are out of scope in this example.

\subsection{Shape of the solution}

A property is any function of type \h{a -> Bool}.
This means that a property can always be written (in Haskell code) as \h{\x -> y} where \h{x} is a variable of type \h{a}, \h{y} is an expression\footnote{that could use \h{x}} and \h{y} is of type `Bool`.
in particular, for the property to be of the input scope, the functions that make up \h{y} must be in scope.

\subsection{Terminals and non-terminals}

\begin{de}
  A terminal variable is either a function in the scope or one of the arguments of the `shape of the solution'.
\end{de}

Throughout the algorithm, new variables will be needed.
These will be fresh variables and they will necessarily be distinct from any terminals and from each other.
As such they will be called \emph{non-terminals}.

\begin{ex}
  In \h{\x -> isPermutationOf y x}, \h{isPermutationOf} and \h{x} are terminal variables but \h{y} is not.
\end{ex}


\subsection{Terminal replacement}

The first step of this algorithm is to try to replace non-terminal variables with terminal variables.
If we can replace any non-terminal variables with terminals, then the resulting function will be a property of the scope.

In the running example, we can first try to replace \h{y} with any of the terminals.
Replacement occurs in two steps.
The first step is type unification and, if that succeeds, the second step is term unification.

\subsubsection{Type unification}

In order to type-unify \h{y} with any terminal, we have to record the appropriate type constraint, and then check if it is satisfiable.

In this case, when trying to unify \h{y :: Bool} with any of the terminals we find the following constraints and solutions:

\begin{tabular}{|l|l|l|}
  \hline
  Replacement & Type Constraints & Solution \\
  \hline
  \hline
  \h{sorted} & \h{(forall a. Ord a => [a] -> Bool) ~ Bool} & Unsatisfiable \\
  \hline
  \h{sort} & \h{(forall a. Ord a => [a] -> [a]) ~ Bool} & Unsatisfiable \\
  \hline
  \h{isPermutationOf} & \h{(forall a. Eq a => [a] -> [a] -> Bool) ~ Bool} & Unsatisfiable \\
  \hline
  \h{x} & \h{a ~ Bool} & \h{a ~ Bool} \\
  \hline
\end{tabular}

In general, there could be more than one non-terminal to try to unify.
In that case, we try all options recursively. \TODO{Work out whether the order matters or not.}

In the table above, we can see that only the unification of \h{y :: Bool} with \h{x :: a} can result in an expression that type-checks.

\subsubsection{Term unification}

Given that the types of the non-terminal that is being replaced and the replacement match, we remember the used constraints, and replace the terms appropirately.

In this case, we would record \h{a ~ Bool} and end up with the expression \h{(\x -> x) :: Bool ~ a => a -> Bool}.
This is just the identity function specialized to \h{Bool} and it is indeed a property of the scope.

\subsection{Non-terminal expansion}

Once all the options for terminal replacement have run out, we move on to the second phase of the algorithm: Non-terminal expansion.
Non-terminal expansion attempts to complicate the property that is being discovered, in order to be able to discover more complicated properties. \TODO{reword.}

In particular, given that we know the desired type-judgement of the property that is being discovered,
non-terminal expansion will explore all possible ways in which this type-judgement could have been made.

For example, the following is the most common type judgement:
[App] in the Hindley-Milner type system. \TODO{Check to make sure that this actually makes sense.}

\[
  \frac{f : a \rightarrow b,\ x : a}{f x : b}
\]

This rule entails that if \h{y} is an expression of type \h{b}, that means that it is possible that it consists of a function application of a function \h{f} of type \h{a -> b} to an expression \h{x} of type \h{a}.
This means that we can expand any non-terminal variable \h{a :: p} to the function application \h{f b :: p} where \h{f} is a fresh non-terminal of type \h{q -> p} and \h{b} is a fresh non-terminal of type \h{q}.

If there are more options for non-terminal expansion, they should all be explored.

In the case of the running example, the non-terminal variable \h{y} will be expanded as follows.
We know that we want the type-checker to judge the expression \h{y} to be of type \h{Bool}
Using the above type-judgement rule, we can now construct the ways in which this could happen.

If we follow this rule backward, and we start with the expression \h{y} in \h{\x -> y}, that we know is of type \h{Bool}, then it could be the case that \h{y} is of the form \h{f z} where \h{f} is of type \h{c -> Bool} and \h{z} is of type \h{c} for some \h{c}.

After a phase of non-terminal expansion, another phase of terminal replacement should occur.
Because it is possible that there exists an infinite number of properties of a given scope, an arbitrary limit must be imposed on the number of phases of the algorithm.
Given that desired properties are usually small, this is not a restrictive limitation.

\subsection{The rest of the example}
The second phase of terminal replacement works on the expression \h{\x -> f z} where we have the following non-terminals:

\begin{itemize}
  \item \h{f :: b -> Bool}
  \item \h{z :: b}
\end{itemize}

For each non-terminal, we explore the constraints of type-unification:

\begin{tabular}{lll}
  Replacement for \h{f} & Type Constraints & Solution \\
  \h{sorted} & \h{(forall a. Ord a => [a] -> Bool) ~ (b -> Bool)} & \h{b ~ [a]} \\
  \h{sort} & \h{(forall a. Ord a => [a] -> [a]) ~ (b -> Bool)} & Unsatisfiable \\
  \h{isPermutationOf} & \h{(forall a. Eq a => [a] -> [a] -> Bool) ~ (b -> Bool)} & Unsatisfiable \\
  \h{x} & \h{a ~ (b -> Bool)} & \h{a ~ (b -> Bool)} \\
\end{tabular}

\begin{tabular}{lll}
  Replacement for \h{z} & Type Constraints & Solution \\
  \h{sorted} & \h{(forall a. Ord a => [a] -> Bool) ~ b} & \h{(forall a. Ord a => [a] -> Bool) ~ b} \\
  \h{sort} & \h{(forall a. Ord a => [a] -> [a]) ~ b} & \h{(forall a. Ord a => [a] -> [a]) ~ b} \\
  \h{isPermutationOf} & \h{(forall a. Eq a => [a] -> [a] -> Bool) ~ b} & \h{(forall a. Eq a => [a] -> [a] -> Bool) ~ b} \\
  \h{x} & \h{a ~ b} & \h{a ~ b} \\
\end{tabular}

We could do the same for \h{z} and arrive at some much more complicated solutions, so let's have a look at what happens if we (term) unify \h{f} with \h{sorted}. \footnote{In the real algorithm, the unification of \h{x} with \h{f} would have to be explored as well.}
This means that \h{b ~ [a]} must hold, and thus that \h{z} must be of type \h{[a]}.

The expression that we are currently looking at is now \h{(\a -> sorted z) :: [a] -> Bool}.
This already looks like a property but it still contains non-terminals so we must go on.

We can now try to unify \h{z} with terminals, and we arrive at the following table as a result.
Note that the scoping of the left-hand side and the right-hand side are independent in these type-equalities.

\begin{tabular}{lll}
  Replacement & Type Constraints & Solution \\
  \h{sorted} & \h{(Ord a => [a] -> Bool) ~ [a]} & Unsatisfiable \\
  \h{sort} & \h{(Ord a => [a] -> [a]) ~ [a]} & Unsatisfiable \\
  \h{isPermutationOf} & \h{(Eq a => [a] -> [a] -> Bool) ~ [a]} & Unsatisfiable \\
  \h{x} & \h{a ~ [a]} & \h{a ~ [a]} \\
\end{tabular}

There is only one option: to (term) unify \h{x} with \h{z}.
This results in the expression \h{\a -> sorted x :: [a] -> Bool}.
This is indeed a property of the set of input functions, even if it does not hold.

If we rewind the last step, then we can use the the trick that we used earlier on \h{y} to split it into \h{f z}, but now on \h{z}.

We can split \h{z :: [a]} into \h{g u :: [a]} where \h{g} is of type \h{d -> [a]} and \h{u} is of type \h{d}.

Now we can (term) unify \h{g} with \h{sort}, analogous to the way we unified \h{f} with \h{sorted} before.
This leaves us with the expression: \h{(\a -> sorted (sort u)) :: [a] -> Bool}.
Here we still have a non-terminal \h{u}, that can be (term) unified with \h{x} to arrive at the property that a sorted list is in fact sorted:
\h{(\x -> sorted (sort x)) :: [a] -> Bool}.

So far we have discovered the following properties:

\begin{itemize}
  \item \h{(\x -> x) :: Bool -> Bool}
  \item \h{(\x -> sorted x) :: [a] -> Bool}
  \item \h{(\x -> sorted (sort x)) :: [a] -> Bool}
\end{itemize}

When we continue this algorithm, the following properties could also be discovered:

\begin{itemize}
  \item \h{(\x -> isPermutationOf (sort x) x) :: [a] -> Bool}
  \item \h{(\x -> sorted (sort (sort x))) :: [a] -> Bool}
  \item \h{(\x -> sorted (sort (sort (sort x)))) :: [a] -> Bool}
  \item ...
\end{itemize}

Note that there are indeed an infinite number of properties to be found given these functions as input.
However, the properties are discovered in increasing size, so by arbitrarily bounding the output properties to a given size, we can make this algorithm terminate.
It makes sense to assume that we are only looking for properties of a relatively small size.
The properties that we are looking for here are \h{(\x -> sorted (sort x)) :: [a] -> Bool}, and \h{(\x -> isPermutationOf (sort x) x) :: [a] -> Bool}, both of which are much smaller that 10 terms.

\TODO{Bound the type variables wherever possible}

\section{Assignment}
\subsection{Objective}

\subsection{Tasks}


\subsection{Deliverables}

\bibliographystyle{plain}
\bibliography{proposal}


\end{document}
