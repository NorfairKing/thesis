\documentclass[a4paper, 11pt, onepage]{article}

\input{packages.tex}
\input{header.tex}

\title{Detailed Master Thesis Proposal:\\\vspace{0.5cm}{\Huge Functional Property Discovery and Corresponding Test Generation in Haskell}}
\author{Tom Sydney Kerckhove}
\begin{document}
\maketitle

\section{Introduction and Motivation}


Correctness of code is currently too expensive.
Current options, in order of decreasing rigour and decreasing cost, include formal methods, testing and having users file bug reports after failures have already ocurred.

When formal methods are too expensive, testing is the most reliable way to ensure that a software system does what it should.
Traditional unit tests have two problems.
The first problem is that unit tests can only be used to show the presence of failures, but can never show the absence of failures.
The second problem is that unit tests require a programmer to provide many examples for the unit tests to be of real value in providing confidence in the implementation.
This requires great discipline on the programmer's part.
Traditional unit tests are still too expensive.
As a result, programmers will all too often omit tests.

Property-based testing \cite{QuickCheck} can probabilistically solve the first problem by automatically generating examples instead of having the programmer think of them.
As such, property-based testing can show failures that the programmers did not anticipate and that the programmer would not have tested for.
However, it exacerbates the second problem.
Now programmers have to come up with mathematical properties of their code.
The transaction costs of writing property tests are even higher than for unit tests.
As a result, however great their benefits, property tests are barely used.

Automatic property tests could resolve the second problem of traditional unit tests.
If properties could automatically be discovered, and their corresponding property tests automatically generated, then programmers would not have to think of any properties, but only decide to enforce the properties.
Relieving a programmer from having to think of examples or properties would make it much cheaper to test software.

Previous work \cite{QuickSpec} has explored automatic discovery of equational properties.
These are properties of the form \mintinline{Haskell}{\x -> f x == g x}, e.g. \mintinline{Haskell}{\xs -> reverse (reverse xs) == xs}.
Equational properties, while certainly useful, fall short in describing real workings of even simple programs.
For example, there is no way to specify the correctness of a sorting algorithm using an equational property.

The first goal of this thesis is to explore automatic discovery of general properties.
General properties allow for more expressive properties such as the correctness of a sorting algorithm.\footnote{The property \mintinline{Haskell}{\xs -> sort xs `isPermutationOf` xs && ordered (sort xs)}, for example, serves to assess the correctness of a sorting algorithm, but can not be expressed as an equational property.}
The second goal is to, once properties have been discovered, generate the code necessary to test that these properties hold.


\section{Type-guided property discovery}

\begin{de}
  A \emph{property} is any Haskell function with a type of the form \h{a -> Bool}.
\end{de}

\begin{ex}
  Examples of properties include \h{sorted :: forall a. Ord a => [a] -> Bool}, \h{increasing :: forall a. Ord a => (a, a) -> Bool} and even the degenerate \h{id :: Bool -> Bool}.

  Note that every boolean function with multiple arguments can be rewritten as a property by uncurrying the arguments.
\end{ex}

\begin{de}
  A \emph{scope} is a set of functions.
  We say that a function is \emph{in scope} if it is an element of the scope.
\end{de}

\begin{de}
  Given a scope, a property is a property \emph{of that scope} if it is made up of functions in scope.
  \footnote{How functions are `made-up' is not strictly defined here. We could restrict this to function application, but choosing to allow more syntax may allow for more building blocks.}
\end{de}

The following algorithm will allow for the discovery of properties given a scope of functions.
It can be generalised to discover functions given their type, but the example that follows is restricted to properties for brevety's sake.


\subsection{Context}

Input: A scope of functions.\\
Output: All possible properties that can be built in this scope.
\footnote{
  Note that this section does not discuss how to choose a scope.
  That problem has no 'correct' solution and will have to be solved later.
}

The following running example will be used, but the algorithm is explained sufficiently generally as well.

Consider the following scope as input.

\begin{itemize}
  \item \h{sorted :: Ord a => [a] -> Bool}:\\ Checks if a list is sorted.
  \item \h{sort :: Ord a => [a] -> [a]}:\\ Sorts a list.
  \item \h{isPermutationOf :: Eq a => [a] -> [a] -> Bool}:\\ Checks if one list is a permutation of an other list.
\end{itemize}

Only these three functions are in scope, we limit the scope to these explicitly mentioned functions.
This means that even commonly used functions like\\ \h{(==) :: Eq a => a -> a -> Bool} or \h{(.) :: (b -> c) -> (a -> b) -> a -> c} are out of scope in this example.


\subsection{Shape of the solution}

A property is any function of type \h{a -> Bool}.
This means that a property can always be written (in Haskell code) as \h{\x -> y} where \h{x} is a variable of type \h{a}, \h{y} is an expression\footnote{that could use \h{x}} and \h{y} is of type \h{Bool}.
in particular, for the property to be of the input scope, the functions that make up \h{y} must be in scope.


\subsection{Terminals and non-terminals}

\begin{de}
  A terminal variable is either a function in the scope or one of the arguments of the `shape of the solution'.
\end{de}

Throughout the algorithm, new variables will be needed.
These will be fresh variables and they will necessarily be distinct from any terminals and from each other.
For the algorithm to discover a property, all of these variables will have to dissappear.
As such they will be called \emph{non-terminals}.

\begin{ex}
  In \h{\x -> isPermutationOf y x}, \h{isPermutationOf} and \h{x} are terminal variables but \h{y} is not.
\end{ex}


\subsection{Terminal replacement}

The first step of this algorithm is to try to replace non-terminal variables with terminal variables.
If we can replace any non-terminal variables with terminals, then the resulting function will be a property of the scope.

In the running example, we can first try to replace \h{y} with any of the terminals.
Replacement occurs in two steps.
The first step is type unification and, if that succeeds, the second step is term unification.


\subsubsection{Type unification}

In order to type-unify \h{y} with any terminal, we have to record the appropriate type constraint, and then check if it is satisfiable.

In general, there could be more than one non-terminal to try to unify.
The details of how to handle this case are handled at the end of this section.

In this case, when trying to unify \h{y :: Bool} with any of the terminals we find the following constraints:

\begin{figure}[H]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    Replacement & Type Constraints \\
    \hline
    \hline
    \h{sorted} & \h{(forall a. Ord a => [a] -> Bool) ~ Bool} \\
    \hline
    \h{sort} & \h{(forall a. Ord a => [a] -> [a]) ~ Bool} \\
    \hline
    \h{isPermutationOf} & \h{(forall a. Eq a => [a] -> [a] -> Bool) ~ Bool} \\
    \hline
    \h{x} & \h{a ~ Bool} \\
    \hline
  \end{tabular}
\end{figure}

Of these options, only the (type) unification of \h{Bool} with \h{a} is satisfiable.
This means that, of these options, only the replacement by \h{x} can result in an expression that type-checks.


\subsubsection{Term unification}

Given that the types of the non-terminal that is being replaced and the replacement match, we can replace the terms appropirately.

In this case, because \h{a ~ Bool} is satisfiable, we can transform \h{(\x -> y) :: a -> Bool} into \h{(\x -> x) :: Bool -> Bool}.
This is just the identity function specialized to \h{Bool} and it is indeed a property of the scope.


\subsection{Non-terminal expansion}

Once all the options for terminal replacement have run out, we move on to the second phase of the algorithm: Non-terminal expansion.
This phase attempts to add complexity to the property that is being discovered.
The resulting expression containing more non-terminals will allow for the discovery of more complex properties in the next phase.

In particular, given that we know the desired type-judgement of the property that is being discovered,
non-terminal expansion will explore all possible ways in which this type-judgement could have been made.

For example, the following is the most common type judgement:
[T-App] in the Hindley-Milner type system. \cite{HM}

\[
  \frac{f : a \rightarrow b,\ x : a}{f x : b}
\]

This rule entails that if \h{y} is an expression of type \h{b}, that means that it is possible that it consists of a function application of a function \h{f} of type \h{a -> b} to an expression \h{x} of type \h{a}.
This means that we can expand any non-terminal variable \h{a :: p} to the function application \h{f b :: p} where \h{f} is a fresh non-terminal of type \h{q -> p} and \h{b} is a fresh non-terminal of type \h{q} where \h{q} is undetermined.
Note that \h{q} is not known but still potentially fixed.

If there are more options for non-terminal expansion, they should all be explored.

In the case of the running example, the non-terminal variable \h{y} will be expanded as follows.
We know that we want the type-checker to judge the expression \h{y} to be of type \h{Bool}
Using the above type-judgement rule, we can now construct the ways in which this could happen.

If we follow this rule backward, and we start with the expression \h{y} in \h{\x -> y}, that we know is of type \h{Bool}, then it could be the case that \h{y} is of the form \h{f z} where \h{f} is of type \h{c -> Bool} and \h{z} is of type \h{c} for some \h{c}.

After a phase of non-terminal expansion, another phase of terminal replacement should occur.
Because it is possible that there exists an infinite number of properties of a given scope, an arbitrary limit must be imposed on the number of phases of the algorithm.
Given that desired properties are usually small, this is not a restrictive limitation.


\subsection{The rest of the example}

\subsubsection{Multiple terminal replacement}

The second phase of terminal replacement works on the expression \h{\x -> f z} where we have the following non-terminals:

\begin{itemize}
  \item \h{f :: b -> Bool}
  \item \h{z :: b}
\end{itemize}

When replacing these non-terminals with terminals, we explore all possible asignments of terminals to non-terminals.
In this case that results in the following options for unification:

\begin{figure}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    Replacement for \h{f} & Replacement for \h{z} \\
    \hline
    \hline
    \h{sorted}            & \h{sorted}          \\
    \hline
    \h{sorted}            & \h{sort}            \\
    \hline
    \h{sorted}            & \h{isPermutationOf} \\
    \hline
    \h{sorted}            & \h{x}               \\
    \hline
    \h{sort}              & *                   \\
    \hline
    \h{isPermutationOf}   & *                   \\
    \hline
    \h{x}                 & *                   \\
    \hline
  \end{tabular}
\end{figure}

Only one of these sixteen sets of constraints is satisfiable.
This is when \h{f} is being replaced by \h{sorted} and \h{z} by \h{x}.
After term unification, we find the property \h{(\x -> sorted x) :: [a] -> Bool}.
This is indeed a property of the set of input functions, even if it does not hold.


\subsubsection{Multiple non-terminal replacement}

From the expression \h{\x -> f z} onwards, there are two options for non-terminal expansion.
Using [App] as before, we can expand \h{f :: b -> Bool} to \h{g u :: b -> Bool} with \h{g :: c -> b -> Bool} and \h{u :: c}.
... Or we can expand \h{z :: b} to \h{h v :: b} with \h{h :: d -> b} and \h{v :: d}.
The algorithm tries both.

To cut a long story short, the first option allows us to discover the property \h{\x -> isPermutationOf x x :: [a] -> Bool}, and later on \h{\x -> isPermutationOf x (sort x) :: [a] -> Bool}.
The second option allows us to discover the property \h{\x -> sorted (sort x)}.

Even further along, also every property of the following form will be discovered.

\begin{itemize}
  \item \h{(\x -> sorted (sort (sort x))) :: [a] -> Bool}
  \item \h{(\x -> sorted (sort (sort (sort x)))) :: [a] -> Bool}
  \item \h{(\x -> sorted (sort (sort (sort (sort x))))) :: [a] -> Bool}
  \item ...
\end{itemize}


\subsection{Type constraint resolution}

A lot has been said about type constraints and their satisfiability.
However, type constraint satisfiability is not a trivial problem.
Luckily, version 8 of the Glasgow Haskell Compiler \cite{GHC8} has a very powerful type constraint satisfiability solver\cite{Schrijvers2015}.
In reality, the algorithm above does not solve any constraints during its operation, but rather collects the possible properties and the appropriate constraints.
Only after the properties and constraints have been discovered, is an attempt made to solve the constraints.
Only the properties with satisfiable type constraints will be proposed as properties of the scope.

\subsection{Proof of concept}

Because this is the most risk-involved part of this proposal, I have created a proof of concept of this algorithm.
See appendix \ref{app:poc}.

\section{Test generation}

Once properties are discovered for a given scope, we can already propose them to a user.
However, generating property tests is not necessarily possible for every property.

To be able to generate a property test for a given property, we require one more additional constraint.
It has to be possible to arbitrarily generate values of the type of the input to the property.

In code, that means that for a property of type \h{a -> Bool}, we need a value of type \h{Gen a} to make a property test.
Luckily QuickCheck\cite{QuickCheck} has defined a type class \h{Arbitrary} of which the members allow for a function called \h{arbitrary :: Gen a} that allows for the arbitrary generation of values.

To generate the test code for a property \h{\x -> y} and generator \h{gen}, the test code is \h{forAll gen $ \x -> y} using QuickCheck \cite{QuickCheck}.

Some times properties still have type variables in their type.
For example, in the case of \h{\x -> reverse (reverse x) == x}, the property's type is parametric in the type of the contents of the list.
Because there are no constraints on the type parameter, we can use any type to fill it in.
\h{Int}, for example.
In the case of \h{\x -> sorted (sort x)}, there is an \h{Ord a} contraint on the type parameter \h{a}.
In that we need only fill it in with a type that has a law-abiding instance of \h{Ord}.
These arbitrary choices work because there is no way to inspect the type without a \h{Typeable} constraint.

\section{Triaging properties}

In the end, a programmer is usually not interested in properties that don't hold.
Instead, it would be a nicer user experience to only be presented with properties that are true.

Given that we can obtain the testing code to test given properties, we can filter out properties that don't hold by testing them.
This testing involves generating a number of arbitrary input values to the property and checking that all the results are \h{True}.


\section{Scope determination}

The entire explanation up until now has been parametric in a scope of functions to use as the input.
Determining this scope is a loosely defined problem.
A smaller scope allows for more efficient property discovery, but omitting too many functions might prohibit the discovery of relevant properties.
Ideally, only the functions that are involved in the property that we want to discover should be in the scope.
Of course we don't know which properties we want to discover, otherwise we would not be trying to discover them.

While scope determination is an unsolved problem, making the user experience good is an independent problem.
We can save the user from having to explicitly declare a scope by using the functions that are in scope for a given module, when discovering properties of that module.
This way the user does not have to specify the scope manually, but this benefit comes at the cost of not being able to discover properties involving functions that are not in scope in the given module.

The complexity limitations of this approach will certainly be explored. 


\section{Assignment}

\subsection{Objective}

Develop a tool that can inspect Haskell code and suggest properties of that code to the programmer.
After the programmer has selected the appropriate properties, the tool generates the necessary code to test these properties.


\subsection{Tasks}

\begin{itemize}
  \item Study and analyse the relevant literature.
  \item Propose a property discovery mechanism.
  \item Implement property discovery.
  \item Implement test code generation.
  \item Assess the feasibility of the property discovery mechanism for increasingly large input programs.
  \item (Optional) Assess the relative advantage of general property testing over equational property testing in a quantitative manner.
  \item (Optional) Explore the tradeoffs of different scope determination options.
  \item Write the final report and prepare a presentation
\end{itemize}


\subsection{Deliverables}

\begin{itemize}
  \item Final report
  \item Tool code and instructions on how to use it.
  \item Presentation
\end{itemize}


\bibliographystyle{plain}
\bibliography{proposal}

\newpage
\appendix

\section{Proof of concept}

\label{app:poc}
\inputminted{Haskell}{poc.hs}

\end{document}
