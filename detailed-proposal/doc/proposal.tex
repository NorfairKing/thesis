\documentclass[a4paper, 11pt]{article}

\input{packages.tex}
\input{header.tex}

\title{Detailed Master Thesis Proposal:\\\vspace{0.5cm}{\Huge Functional Property Discovery and Corresponding Test Generation in Haskell}}
\author{Tom Sydney Kerckhove}
\begin{document}
\maketitle

\section{Introduction and Motivation}


Correctness of code is currently too expensive.
Current options, in order of decreasing rigour and decreasing cost, include formal methods, testing and having users file bug reports after failures have already ocurred.

When formal methods are too expensive, testing is the most reliable way to ensure that a software system does what it should.
Traditional unit tests have two problems.
The first problem is that unit tests can only be used to show the presence of failures, but can never show the absence of failures.
The second problem is that unit tests require a programmer to provide many examples for the unit tests to be of real value in providing confidence in the implementation.
This requires great discipline on the programmer's part.
Traditional unit tests are still too expensive.
As a result, programmers will all too often omit tests.

Property-based testing \cite{QuickCheck} can probabilistically solve the first problem by automatically generating examples instead of having the programmer think of them.
As such, property-based testing can show failures that the programmers did not anticipate and that the programmer would not have tested for.
However, it exacerbates the second problem.
Now programmers have to come up with mathematical properties of their code.
The transaction costs of writing property tests are even higher than for unit tests.
As a result, however great their benefits, property tests are barely used.

Automatic property tests could resolve the second problem of traditional unit tests.
If properties could automatically be discovered, and their corresponding property tests automatically generated, then programmers would not have to think of any properties, but only decide to enforce the properties.
Relieving a programmer from having to think of examples or properties would make it much cheaper to test software.

Previous work \cite{QuickSpec} has explored automatic discovery of equational properties.
These are properties of the form \mintinline{Haskell}{\x -> f x == g x}, e.g. \mintinline{Haskell}{\xs -> reverse (reverse xs) == xs}.
Equational properties, while certainly useful, fall short in describing real workings of even simple programs.
For example, there is no way to specify the correctness of a sorting algorithm using an equational property.

The first goal of this thesis is to explore automatic discovery of general properties.
General properties allow for more expressive properties such as the correctness of a sorting algorithm.\footnote{The property \mintinline{Haskell}{\xs -> sort xs `isPermutationOf` xs && ordered (sort xs)}, for example, serves to assess the correctness of a sorting algorithm, but can not be expressed as an equational property.}
The second goal is to, once properties have been discovered, generate the code necessary to test that these properties hold.

\newpage

\section{Type-guided property discovery}

\begin{de}
  A \emph{property} is any Haskell function with a type of the form \h{a -> Bool}.
\end{de}

\begin{ex}
  Examples of properties include \h{sorted :: forall a. Ord a => [a] -> Bool}, \h{increasing :: forall a. Ord a => (a, a) -> Bool} and even the degenerate \h{id :: Bool -> Bool}.

  Note that every boolean function with multiple arguments can be rewritten as a property by uncurrying the arguments.
\end{ex}

\begin{de}
  A \emph{scope} is a set of functions.
  We say that a function is \emph{in scope} if it is an element of the scope.
\end{de}

\begin{de}
  Given a scope, a property is a property \emph{of that scope} if it is made up of functions in scope.
  \footnote{How functions are `made-up' is not strictly defined here. We could restrict this to function application, but choosing to allow more syntax may allow for more building blocks.}
\end{de}

\section{Type-guided property discovery}

The following algorithm will allow for the discovery of properties given a scope of functions.
It can be generalised to discover functions given their type, but the example that follows is restricted to properties for brevety's sake.

\subsection{Context}

Input: A scope of functions.\\
Output: All possible properties that can be built in this scope.
\footnote{
  Note that this section does not discuss how to choose a scope.
  That problem has no 'correct' solution and will have to be solved later.
}

The following running example will be used, but the algorithm is explained sufficiently generally as well.

Consider the following scope as input.

\begin{itemize}
  \item \h{sorted :: Ord a => [a] -> Bool}
  \item \h{sort :: Ord a => [a] -> [a]}
  \item \h{isPermutationOf :: Eq a => [a] -> [a] -> Bool}
\end{itemize}

Only these three functions are in scope, we limit the scope to these explicitly mentioned functions.
This means that even commonly used functions like\\ \h{(==) :: Eq a => a -> a -> Bool} or \h{(.) :: (b -> c) -> (a -> b) -> a -> c} are out of scope in this example.

\subsection{Shape of the solution}

A property is any function of type \h{a -> Bool}.
This means that a property can always be written (in Haskell code) as \h{\x -> y} where \h{x} is a variable of type \h{a}, \h{y} is an expression\footnote{that could use \h{x}} and \h{y} is of type \h{Bool}.
in particular, for the property to be of the input scope, the functions that make up \h{y} must be in scope.

\subsection{Terminals and non-terminals}

\begin{de}
  A terminal variable is either a function in the scope or one of the arguments of the `shape of the solution'.
\end{de}

Throughout the algorithm, new variables will be needed.
These will be fresh variables and they will necessarily be distinct from any terminals and from each other.
For the algorithm to discover a property, all of these variables will have to dissappear.
As such they will be called \emph{non-terminals}.

\begin{ex}
  In \h{\x -> isPermutationOf y x}, \h{isPermutationOf} and \h{x} are terminal variables but \h{y} is not.
\end{ex}


\subsection{Terminal replacement}

The first step of this algorithm is to try to replace non-terminal variables with terminal variables.
If we can replace any non-terminal variables with terminals, then the resulting function will be a property of the scope.

In the running example, we can first try to replace \h{y} with any of the terminals.
Replacement occurs in two steps.
The first step is type unification and, if that succeeds, the second step is term unification.

\subsubsection{Type unification}

In order to type-unify \h{y} with any terminal, we have to record the appropriate type constraint, and then check if it is satisfiable.

In this case, when trying to unify \h{y :: Bool} with any of the terminals we find the following constraints and solutions:

\begin{tabular}{|l|l|l|}
  \hline
  Replacement & Type Constraints & Solution \\
  \hline
  \hline
  \h{sorted} & \h{(forall a. Ord a => [a] -> Bool) ~ Bool} & Unsatisfiable \\
  \hline
  \h{sort} & \h{(forall a. Ord a => [a] -> [a]) ~ Bool} & Unsatisfiable \\
  \hline
  \h{isPermutationOf} & \h{(forall a. Eq a => [a] -> [a] -> Bool) ~ Bool} & Unsatisfiable \\
  \hline
  \h{x} & \h{a ~ Bool} & \h{a ~ Bool} \\
  \hline
\end{tabular}

In general, there could be more than one non-terminal to try to unify.
The details of how to handle this case are handled at the end of this section.

In the table above, we can see that only the unification of \h{y :: Bool} with \h{x :: a} can result in an expression that type-checks.

\subsubsection{Term unification}

Given that the types of the non-terminal that is being replaced and the replacement match, we remember the used constraints, and replace the terms appropirately.

In this case, we would record \h{a ~ Bool} and end up with the expression \h{(\x -> x) :: Bool ~ a => a -> Bool}.
This is just the identity function specialized to \h{Bool} and it is indeed a property of the scope.

\subsection{Non-terminal expansion}

Once all the options for terminal replacement have run out, we move on to the second phase of the algorithm: Non-terminal expansion.
This phase attempts to add complexity to the property that is being discovered.
The resulting expression containing non-terminals will allow for the discovery of more complex properties in the next phase.

In particular, given that we know the desired type-judgement of the property that is being discovered,
non-terminal expansion will explore all possible ways in which this type-judgement could have been made.

For example, the following is the most common type judgement:
[App] in the Hindley-Milner type system. \TODO{Check to make sure that this actually makes sense.}

\[
  \frac{f : a \rightarrow b,\ x : a}{f x : b}
\]

This rule entails that if \h{y} is an expression of type \h{b}, that means that it is possible that it consists of a function application of a function \h{f} of type \h{a -> b} to an expression \h{x} of type \h{a}.
This means that we can expand any non-terminal variable \h{a :: p} to the function application \h{f b :: p} where \h{f} is a fresh non-terminal of type \h{q -> p} and \h{b} is a fresh non-terminal of type \h{q}.

If there are more options for non-terminal expansion, they should all be explored.

In the case of the running example, the non-terminal variable \h{y} will be expanded as follows.
We know that we want the type-checker to judge the expression \h{y} to be of type \h{Bool}
Using the above type-judgement rule, we can now construct the ways in which this could happen.

If we follow this rule backward, and we start with the expression \h{y} in \h{\x -> y}, that we know is of type \h{Bool}, then it could be the case that \h{y} is of the form \h{f z} where \h{f} is of type \h{c -> Bool} and \h{z} is of type \h{c} for some \h{c}.

After a phase of non-terminal expansion, another phase of terminal replacement should occur.
Because it is possible that there exists an infinite number of properties of a given scope, an arbitrary limit must be imposed on the number of phases of the algorithm.
Given that desired properties are usually small, this is not a restrictive limitation.

\subsection{The rest of the example}
\subsubsection{Multiple terminal replacement}
The second phase of terminal replacement works on the expression \h{\x -> f z} where we have the following non-terminals:

\begin{itemize}
  \item \h{f :: b -> Bool}
  \item \h{z :: b}
\end{itemize}

When replacing these non-terminals with terminals, we explore the cross-product of all the options for terminals for each non-terminal.
In this case that results in the following type-unification solutions:

\begin{tabular}{lll}
  Replacement for \h{f} & Replacement for \h{z} & Solution \\
  \h{sorted}            & \h{sorted}            &  Not satisfiable \\
  \h{sorted}            & \h{sort}              &  Not satisfiable \\
  \h{sorted}            & \h{isPermutationOf}   &  Not satisfiable \\
  \h{sorted}            & \h{x}                 &  \h{b ~ [a]}     \\
  \h{sort}              & *                     &  Not satisfiable \\
  \h{isPermutationOf}   & *                     &  Not satisfiable \\
  \h{x}                 & *                     &  Not satisfiable \\
\end{tabular}

This leaves us with exactly one option for a property.
After term unification, we find that this is the property \h{\x -> sorted x :: [a] -> Bool}.

This results in the expression \h{\a -> sorted x :: [a] -> Bool}.
This is indeed a property of the set of input functions, even if it does not hold.

\subsubsection{Multiple non-terminal replacement}

From the expression \h{\x -> f z} onwards, there are two options for non-terminal expansion.
Using [App] as before, we can expand \h{f :: b -> Bool} to \h{g u :: b -> Bool} with \h{g :: c -> b -> Bool} and \h{u :: c}.
... Or we can expand \h{z :: b} to \h{h v :: b} with \h{h :: d -> b} and \h{v :: d}.
The algorithm should try both.

To cut a long story short, the first option allows us to discover the property \h{\x -> isPermutationOf x x :: [a] -> Bool}, and later on \h{\x -> isPermutationOf x (sort x) :: [a] -> Bool}.
The second option allows us to discover the property \h{\x -> sorted (sort x)}.

Even further along, also every property of the following form will be discovered.

\begin{itemize}
  \item \h{(\x -> sorted (sort (sort x))) :: [a] -> Bool}
  \item \h{(\x -> sorted (sort (sort (sort x)))) :: [a] -> Bool}
  \item \h{(\x -> sorted (sort (sort (sort (sort x))))) :: [a] -> Bool}
  \item ...
\end{itemize}

\section{Test generation}

Once properties are discovered for a given scope, we can already propose them to a user.
However, generating property tests is not necessarily possible for every property.

To be able to generate a property test for a given property, we require one more additional constraint.
It has to be possible to arbitrarily generate values of the type of the input to the property.

In code, that means that for a property of type \h{a -> Bool}, we need a value of type \h{Gen a} to make a property test.
Luckily QuickCheck\cite{QuickCheck} has defined a type class \h{Arbitrary} of which the members allow for a function called \h{arbitrary :: Gen a} that allows for the arbitrary generation of values.

To generate the test code for a property \h{\x -> y} and generator \h{gen}, the test code is \h{forAll gen $ \x -> y} using the standard hspec\cite{hspec}\TODO{cite hspec} test framework.

\TODO{what do we do with parametric code?}

\section{Triaging properties}

In the end, a programmer is usually not interested in properties that don't hold.
Instead, it would be a nicer user experience to only be presented with properties that are true.

Given that we can obtain the testing code to test given properties, we can filter out properties that don't hold by testing them.
This testing involves generating a number of arbitrary input values to the property and checking that all the results are \h{True}.

\section{Scope determination}

The entire explanation up until now has been parametric in a scope of functions to use as the input.
Determining this scope is a loosely defined problem.
A smaller scope allows for more efficient property discovery, but omitting too many functions might prohibit the discovery of relevant properties.
Ideally, only the functions that are involved in the property that we want to discover should be in the scope.
Of course we don't know which properties we want to discover, otherwise we would not be trying to discover them.

While scope determination is an unsolved problem, making the user experience good is an independent problem.
We can save the user from having to explicitly declare a scope by using the functions that are in scope for a given module, when discovering properties of that module.
This way the user does not have to specify the scope manually, but this benefit comes at the cost of not being able to discover properties involving functions that are not in scope in the given module.

The complexity limitations of this approach will certainly be explored. 

\section{Assignment}
\subsection{Objective}

\subsection{Tasks}


\subsection{Deliverables}

\bibliographystyle{plain}
\bibliography{proposal}


\end{document}
