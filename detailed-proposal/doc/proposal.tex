\documentclass[a4paper, 11pt]{article}

\input{packages.tex}
\input{header.tex}

\title{Detailed Master Thesis Proposal:\\\vspace{0.5cm}{\Huge Functional Property Discovery and Corresponding Test Generation in Haskell}}
\author{Tom Sydney Kerckhove}
\begin{document}
\maketitle

\section{Introduction and Motivation}

\newpage

\section{Type-guided property discovery}

\begin{de}
\end{de}

\section{Type-guided property discovery}

Input: A set of functions that are 'in scope'.
Output: All possible properties that can be built with these functions.

Example:
Input: 
\begin{itemize}
  \item \h{sorted :: Ord a => [a] -> Bool}
  \item \h{sort :: Ord a => [a] -> [a]}
  \item \h{isPermutationOf :: Eq a => [a] -> [a] -> Bool}
\end{itemize}

A property is any function of type \h{a -> Bool} \footnote{Later it will become necessary that \h{a} is a type of which values can be generated arbitrarily.}.
This means that a property can always be written (in Haskell code) as \h{\x -> y} where \h{x} is a variable of type \h{a}, \h{y} is an expression that can use \h{x} and \h{y} is of type `Bool`.

At this point we have these terms in 'play':

\begin{itemize}
  \item \h{sorted :: Ord a => [a] -> Bool}
  \item \h{sort :: Ord a => [a] -> [a]}
  \item \h{isPermutationOf :: Eq a => [a] -> [a] -> Bool}
  \item \h{x :: a}
\end{itemize}

... and the following non-terminal terms:

\begin{itemize}
  \item \h{y :: Bool}
\end{itemize}

We could try to replace \h{y} with any of the terms in play, by first collecting the type constraints that would imply.
For example, we could try to replace \h{y} with \h{x}.
This means that we have to solve \h{a ~ Bool}.
The result would be a terminal property \h{\a -> a} of type \h{Bool -> Bool}.
This is the identity function.
One could argue that this is indeed a property of the input functions.
\footnote{Even if every set of input functions will allow for the discovery of this function and it does not hold for any input set.}

When we disregard replacing \h{y}, for the sake of preventing infinite loops, only the input functions remain as options.
In particular, trying to replace \h{y} with any of \h{sorted} \h{sort} or \h{isPermutationOf} will result in the unsatisfiable type constraints \h{(Ord a => [a] -> Bool) ~ Bool}, \h{(Ord a => [a] -> [a]) ~ Bool} or \h{(Eq a => [a] -> [a] -> Bool) ~ Bool}.

Now that the options for direct term unification have run out, we can try to expand any of the relevant term in the current expression \h{\x -> y}.
The only relevant term to replace is \h{y}, so we will have a look at how we can expand \h{y} in the next section.


Given that we want the type-checker to judge the expression \h{y} to be of type \h{Bool}, we can now construct the ways in which this could happen.
If we look at how type judgements are made, we can see how \h{y} can be made up of the functions in the input.

The most common type judgements is made according to the following rule:

\[
  \frac{f : a \rightarrow b,\ x : a}{f x : b}
\]

This rule entails that if \h{y} is an expression of type \h{b}, that means that it is possible that it consists of a function application of a function \h{f} of type \h{a -> b} to an expression \h{x} of type \h{a}.

If we follow this rule backward, and we start with the expression \h{y} in \h{\x -> y}, that we know is of type \h{Bool}, then it could be the case that \h{y} is of the form \h{f z} where \h{f} is of type \h{b -> Bool} and \h{z} is of type \h{c} for some \h{c}.
Note that \h{z} does not necessarily have to equal \h{x} and \h{c} does not necessarily have to equal \h{a}.
It could be the case that \h{x} is used somewhere else in \h{f} or even not at all.

At this point we have these terms in 'play':

\begin{itemize}
  \item \h{sorted :: Ord a => [a] -> Bool}
  \item \h{sort :: Ord a => [a] -> [a]}
  \item \h{isPermutationOf :: Eq a => [a] -> [a] -> Bool}
  \item \h{x :: a}
\end{itemize}

... and the following non-terminal terms:

\begin{itemize}
  \item \h{f :: b -> Bool}
  \item \h{z :: b}
\end{itemize}
\TODO{explain dependent type scoping for non-terminals and independent type scoping for terminals.}

In the following table, we can see the type-constraints that occur when we try to unify the terms in play with \h{f}.

\begin{tabular}{lll}
  Replacement & Type Constraints & Solution \\
  \h{sorted} & \h{(Ord a => [a] -> Bool) ~ (b -> Bool)} & \h{b ~ [a]} \\
  \h{sort} & \h{(Ord a => [a] -> [a]) ~ (b -> Bool)} & Unsatisfiable \\
  \h{isPermutationOf} & \h{(Eq a => [a] -> [a] -> Bool) ~ (b -> Bool)} & Unsatisfiable \\
  \h{x} & \h{a ~ (b -> Bool)} & \h{a ~ (b -> Bool)} \\
\end{tabular}

We could do the same for \h{z} and arrive at some much more complicated solutions, so let's have a look at what happens if we (term) unify \h{f} with \h{sorted}. \footnote{In the real algorithm, the unification of \h{x} with \h{f} would have to be explored as well.}
This means that \h{b ~ [a]} must hold, and thus that \h{z} must be of type \h{[a]}.

The expression that we are currently looking at is now \h{(\a -> sorted z) :: [a] -> Bool}.
This already looks like a property but it still contains non-terminals so we must go on.

We can now try to unify \h{z} with terminals, and we arrive at the following table as a result.
Note that the scoping of the left-hand side and the right-hand side are independent in these type-equalities.

\begin{tabular}{lll}
  Replacement & Type Constraints & Solution \\
  \h{sorted} & \h{(Ord a => [a] -> Bool) ~ [a]} & Unsatisfiable \\
  \h{sort} & \h{(Ord a => [a] -> [a]) ~ [a]} & Unsatisfiable \\
  \h{isPermutationOf} & \h{(Eq a => [a] -> [a] -> Bool) ~ [a]} & Unsatisfiable \\
  \h{x} & \h{a ~ [a]} & \h{a ~ [a]} \\
\end{tabular}

There is only one option: to (term) unify \h{x} with \h{z}.
This results in the expression \h{\a -> sorted x :: [a] -> Bool}.
This is indeed a property of the set of input functions, even if it does not hold.

If we rewind the last step, then we can use the the trick that we used earlier on \h{y} to split it into \h{f z}, but now on \h{z}.

We can split \h{z :: [a]} into \h{g u :: [a]} where \h{g} is of type \h{d -> [a]} and \h{u} is of type \h{d}.

Now we can (term) unify \h{g} with \h{sort}, analogous to the way we unified \h{f} with \h{sorted} before.
This leaves us with the expression: \h{(\a -> sorted (sort u)) :: [a] -> Bool}.
Here we still have a non-terminal \h{u}, that can be (term) unified with \h{x} to arrive at the property that a sorted list is in fact sorted:
\h{(\x -> sorted (sort x)) :: [a] -> Bool}.

So far we have discovered the following properties:

\begin{itemize}
  \item \h{(\x -> x) :: Bool -> Bool}
  \item \h{(\x -> sorted x) :: [a] -> Bool}
  \item \h{(\x -> sorted (sort x)) :: [a] -> Bool}
\end{itemize}

When we continue this algorithm, the following properties could also be discovered:

\begin{itemize}
  \item \h{(\x -> isPermutationOf (sort x) x) :: [a] -> Bool}
  \item \h{(\x -> sorted (sort (sort x))) :: [a] -> Bool}
  \item \h{(\x -> sorted (sort (sort (sort x)))) :: [a] -> Bool}
  \item ...
\end{itemize}

Note that there are indeed an infinite number of properties to be found given these functions as input.
However, the properties are discovered in increasing size, so by arbitrarily bounding the output properties to a given size, we can make this algorithm terminate.
It makes sense to assume that we are only looking for properties of a relatively small size.
The properties that we are looking for here are \h{(\x -> sorted (sort x)) :: [a] -> Bool}, and \h{(\x -> isPermutationOf (sort x) x) :: [a] -> Bool}, both of which are much smaller that 10 terms.

\TODO{Bound the type variables wherever possible}

\section{Assignment}
\subsection{Objective}

\subsection{Tasks}


\subsection{Deliverables}

\bibliographystyle{plain}
\bibliography{proposal}


\end{document}
